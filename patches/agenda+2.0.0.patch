patch-package
--- a/node_modules/agenda/lib/agenda/find-and-lock-next-job.js
+++ b/node_modules/agenda/lib/agenda/find-and-lock-next-job.js
@@ -1,8 +1,8 @@
-'use strict';
-const debug = require('debug')('agenda:internal:_findAndLockNextJob');
-const utils = require('../utils');
+"use strict"
+const debug = require("debug")("agenda:internal:_findAndLockNextJob")
+const utils = require("../utils")
 
-const createJob = utils.createJob;
+const createJob = utils.createJob
 
 /**
  * Find and lock jobs
@@ -16,24 +16,28 @@ const createJob = utils.createJob;
  * @returns {undefined}
  */
 module.exports = function(jobName, definition, cb) {
-  const self = this;
-  const now = new Date();
-  const lockDeadline = new Date(Date.now().valueOf() - definition.lockLifetime);
-  debug('_findAndLockNextJob(%s, [Function], cb)', jobName);
+  const self = this
+  const now = new Date()
+  const lockDeadline = new Date(Date.now().valueOf() - definition.lockLifetime)
+  debug("_findAndLockNextJob(%s, [Function], cb)", jobName)
 
   // Don't try and access MongoDB if we've lost connection to it.
   // Trying to resolve crash on Dev PC when it resumes from sleep. NOTE: Does this still happen?
-  const s = this._mdb.s || this._mdb.db.s;
+  const s = this._mdb.s || this._mdb.db.s
   if (s.topology.connections().length === 0) {
     if (s.topology.autoReconnect && !s.topology.isDestroyed()) {
       // Continue processing but notify that Agenda has lost the connection
-      debug('Missing MongoDB connection, not attempting to find and lock a job');
-      self.emit('error', new Error('Lost MongoDB connection'));
-      cb();
+      debug("Missing MongoDB connection, not attempting to find and lock a job")
+      self.emit("error", new Error("Lost MongoDB connection"))
+      cb()
     } else {
       // No longer recoverable
-      debug('topology.autoReconnect: %s, topology.isDestroyed(): %s', s.topology.autoReconnect, s.topology.isDestroyed());
-      cb(new Error('MongoDB connection is not recoverable, application restart required'));
+      debug(
+        "topology.autoReconnect: %s, topology.isDestroyed(): %s",
+        s.topology.autoReconnect,
+        s.topology.isDestroyed()
+      )
+      cb(new Error("MongoDB connection is not recoverable, application restart required"))
     }
   } else {
     // /**
@@ -41,46 +45,58 @@ module.exports = function(jobName, definition, cb) {
     // * @type {{$or: [*]}}
     // */
     const JOB_PROCESS_WHERE_QUERY = {
-      $or: [{
-        name: jobName,
-        lockedAt: null,
-        nextRunAt: {$lte: this._nextScanAt},
-        disabled: {$ne: true}
-      }, {
-        name: jobName,
-        lockedAt: {$exists: false},
-        nextRunAt: {$lte: this._nextScanAt},
-        disabled: {$ne: true}
-      }, {
-        name: jobName,
-        lockedAt: {$lte: lockDeadline},
-        disabled: {$ne: true}
-      }]
-    };
+      $or: [
+        {
+          name: jobName,
+          lockedAt: null,
+          nextRunAt: { $lte: this._nextScanAt },
+          disabled: { $ne: true },
+        },
+        {
+          name: jobName,
+          lockedAt: { $exists: false },
+          nextRunAt: { $lte: this._nextScanAt },
+          disabled: { $ne: true },
+        },
+        {
+          name: jobName,
+          lockedAt: { $lte: lockDeadline },
+          disabled: { $ne: true },
+        },
+      ],
+    }
 
     /**
-    * Query used to set a job as locked
-    * @type {{$set: {lockedAt: Date}}}
-    */
-    const JOB_PROCESS_SET_QUERY = {$set: {lockedAt: now}};
+     * Query used to set a job as locked
+     * @type {{$set: {lockedAt: Date}}}
+     */
+    const JOB_PROCESS_SET_QUERY = { $set: { lockedAt: now } }
 
     /**
-    * Query used to affect what gets returned
-    * @type {{returnOriginal: boolean, sort: object}}
-    */
-    const JOB_RETURN_QUERY = {returnOriginal: false, sort: this._sort};
+     * Query used to affect what gets returned
+     * @type {{returnOriginal: boolean, sort: object}}
+     */
+    const JOB_RETURN_QUERY = { returnOriginal: false, sort: this._sort }
 
     // Find ONE and ONLY ONE job and set the 'lockedAt' time so that job begins to be processed
-    this._collection.findOneAndUpdate(JOB_PROCESS_WHERE_QUERY, JOB_PROCESS_SET_QUERY, JOB_RETURN_QUERY, (err, result) => {
-      let job;
-      if (!err && result.value) {
-        debug('found a job available to lock, creating a new job on Agenda with id [%s]', result.value._id);
-        job = createJob(self, result.value);
-      }
-      if (err) {
-        debug('error occurred when running query to find and lock job');
+    this._collection.findOneAndUpdate(
+      JOB_PROCESS_WHERE_QUERY,
+      JOB_PROCESS_SET_QUERY,
+      JOB_RETURN_QUERY,
+      (err, result) => {
+        let job
+        if (!err && result.value) {
+          debug("found a job available to lock, creating a new job on Agenda with id [%s]", result.value._id)
+          job = createJob(self, result.value)
+        }
+        if (err) {
+          debug("error occurred when running query to find and lock job")
+        }
+        if (!result.value) {
+          debug("did not find a job to lock")
+        }
+        cb(err, job)
       }
-      cb(err, job);
-    });
+    )
   }
-};
+}
